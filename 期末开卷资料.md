## 1. 插入排序

最优$O(n)$，最差$O(n^2)$

## 2. 时间复杂度表示

### 2.1 渐进标记

* $O$标记：描述函数的渐进上界，存在正数$c$和$n_0$，满足：


$$
0≤𝑓(𝑛)≤cg(𝑛) \; for\;all\;𝑛≥𝑛_0
$$

* $\Omega$标记：描述函数的渐进下界，存在正数$c$和$n_0$，满足：

$$
0≤cg(𝑛) ≤𝑓(𝑛)  \; for\;all\;𝑛≥𝑛_0
$$

* $\Theta$标记：描述函数的渐进紧确界，存在整数$c1$、$c2$、$n_0$，满足：

$$
0≤𝑐_1 g(𝑛) ≤𝑓(𝑛)≤𝑐_2 g(𝑛)\; for\;all\;𝑛≥𝑛_0
$$

重要结论：

对于任意函数$f(n)$和$g(n)$，有：
$$
𝑓(𝑛)=Θ(g(𝑛)) \; if\;and\;only\;if  \\𝑓(𝑛)=𝑂(g(𝑛))\;and\;𝑓(𝑛)=Ω(g(𝑛)) 
$$

### 2.2 作业

1. Let f(n) and g(n) be asymptotically nonnegative functions. Using the basic definition of Θ-notation, prove that 

$$
max⁡[{𝑓(𝑛),𝑔(𝑛)}]=Θ(𝑓(𝑛)+𝑔(𝑛)).
$$

**Answer**: Since $f(n)$ and $g(n)$ are asymptotically nonnegative, there exists $n_1$ and $n_2$ such that $f(n)≥0$ for all $n≥n_1$ and $g(n)≥0$ for all $n≥n_2$. Let $n_0$=$max \{n_1, n_2\}$, and hence $f(n)≥0$ and $g(n)≥0$ for all $n≥n_0$

For all $n≥n_0$, we have
$$
\begin{gathered}
0 \leq f(n) \leq \max \{f(n), g(n)\}, \\
0 \leq g(n) \leq \max \{f(n), g(n)\}, \ldots . \\
0 \leq \max \{f(n), g(n)\} \leq f(n)+g(n) .
\end{gathered}
$$
Adding the first two inequalities, it can be derived that
$$
0 \leq(f(n)+g(n)) / 2 \leq \max \{f(n), g(n)\}
$$
According to the definition of Θ-notation, $c_1=1∕2$ and $c_2=1$, for all $n≥n_0$,
$$
0 \leq(f(n)+g(n)) / 2 \leq \max \{f(n), g(n)\} \leq f(n)+g(n)
$$
Therefore, $max \{f(n), g(n)\}=Θ(f(n)+g(n))$.

2. Explain why the statement, “The running time of algorithm A is at least $O(n^2)$,” is meaningless

**Answer**:Let the running time be $T(n)$. $T(n)≥O(n^2)$ means that $T(n)≥f(n)$ for some function $f(n)$ in the set $O(n^2)$. In fact, this statement holds for any running time $T(n)$, since the function $g(n)=0$ for all n is in $O(n^2)$, and running times are always nonnegative. Thus, the statement tells us nothing about the running time.

## 3. 分治法（Divide and Conquer）

* **Divide** the problem into one or more subproblems that are smaller instances of the same problem

* **Conquer** the subproblems by solving them recursively

* **Combine** the subproblem solutions to form a solution to the original problem

### 3.1 归并排序

![image-20231224213549136](C:\Users\27476\Desktop\算法教材\图图\image-20231224213549136.png)

复杂度分析：

* 代入法（**substitution method**）

第一步：使用常数符号猜测解的形式；第二步：是用数学归纳法求出解中的常数，并证明解是正确的

例如，$T(n)=2 T(\lfloor n / 2\rfloor)+\Theta(n) \text { ,猜测 } T(n)=O(n \lg n)$

![image-20231224214305560](C:\Users\27476\Desktop\算法教材\图图\image-20231224214305560.png)

只要，$c$和$n_0$足够大，就可以隐藏掉$\Theta(n)$。数学归纳法要求除了归纳情况满足之外，基本情况也要满足，即当$n_0 \leq n \leq 2n_0$时有$T(n) \leq cnlgn$

![image-20231224214533652](C:\Users\27476\Desktop\算法教材\图图\image-20231224214533652.png)

**注意**：要证明的是$T(n)\leq f(n)$，而不是$T(n) \leq O(n)$

* 递归树法

例如，$T(n)=3T(\frac{n}{4})+\Theta(n^2)=3T(n)+c_2n^2$

![image-20231224215140866](C:\Users\27476\Desktop\算法教材\图图\image-20231224215140866.png)

![image-20231224215206990](C:\Users\27476\Desktop\算法教材\图图\image-20231224215206990.png)

* 主方法：主要用于求解下面格式的递归式


$$
T(n)=a T(n / b)+f(n) \text { ，其中 } a>0, b>1
$$
其中，驱动函数为$f(n)$

![image-20231224215626706](C:\Users\27476\Desktop\算法教材\图图\image-20231224215626706.png)

情况1的实例：

![image-20231224215823619](C:\Users\27476\Desktop\算法教材\图图\image-20231224215823619.png)

情况2的实例：

![image-20231224220032182](C:\Users\27476\Desktop\算法教材\图图\image-20231224220032182.png)

### 3.2 作业

1. For each of the following recurrences, sketch its recursion tree, and guess a good asymptotic upper bound on its solution. Then use the substitution method to verify your answer

![image-20231224220523621](C:\Users\27476\Desktop\算法教材\图图\image-20231224220523621.png)

![image-20231224220653559](C:\Users\27476\Desktop\算法教材\图图\image-20231224220653559.png)

2. Use the master method to give tight asymptotic bounds for the following recurrences

![image-20231224221027044](C:\Users\27476\Desktop\算法教材\图图\image-20231224221027044.png)

****

![image-20231224221050172](C:\Users\27476\AppData\Roaming\Typora\typora-user-images\image-20231224221050172.png)

****

![image-20231224221102819](C:\Users\27476\AppData\Roaming\Typora\typora-user-images\image-20231224221102819.png)

## 四. 动态规划（Dynamic Programming）

![image-20231225112118620](C:\Users\27476\Desktop\算法教材\图图\image-20231225112118620.png)

设计一个动态规划算法一般有以下四步：

* 描述一个最优解的结构特征
* 递归地定义最优解的值
* 计算最优解的值，通常采用自底向上的方法
* 利用计算出的信息构造出一个最优解

### 4.1 钢条切割问题（rod-cutting）

![image-20231225112505607](C:\Users\27476\Desktop\算法教材\图图\image-20231225112505607.png)

* 自顶向下递归实现

![image-20231225112643470](C:\Users\27476\Desktop\算法教材\图图\image-20231225112643470.png)

分析CUT-ROD的运行时间：$T(0)=1$，$T(n)=1+ \sum^{n-1}_{j=0}T(j)$，解得$T(n)=2^n$

* 使用动态规划

![image-20231225112857878](C:\Users\27476\Desktop\算法教材\图图\image-20231225112857878.png)

动态规划有两种实现方法

![image-20231225113033189](C:\Users\27476\Desktop\算法教材\图图\image-20231225113033189.png)

**记忆化的自顶向下**：

![image-20231225113426184](C:\Users\27476\Desktop\算法教材\图图\image-20231225113426184.png)

**自底向上**：

![image-20231225113558338](C:\Users\27476\Desktop\算法教材\图图\image-20231225113558338.png)

为了重构最优解，可以对上述函数进行改造：

![image-20231225113824023](C:\Users\27476\Desktop\算法教材\图图\image-20231225113824023.png)

### 4.2 最长公共子序列（LCS）

![image-20231225114008041](C:\Users\27476\Desktop\算法教材\图图\image-20231225114008041.png)

**LCS的最优子结构**：

![image-20231225114109538](C:\Users\27476\Desktop\算法教材\图图\image-20231225114109538.png)

**LCS的一个递归解**：

![image-20231225114206419](C:\Users\27476\Desktop\算法教材\图图\image-20231225114206419.png)

**计算LCS的长度**：

LCS问题有$\Theta(mn)$个不同的子问题，可以采用自底向上动态规划进行计算。

![image-20231225114404171](C:\Users\27476\Desktop\算法教材\图图\image-20231225114404171.png)

![image-20231225114424776](C:\Users\27476\Desktop\算法教材\图图\image-20231225114424776.png)

计算每个表项的运行时间为$\Theta(1)$，所以LCS-LENGTH的运行时间为$\Theta(mn)$

**构造一个LCS**：

![image-20231225114710138](C:\Users\27476\Desktop\算法教材\图图\image-20231225114710138.png)

**本题也可以使用记忆化自顶向下动态规划求解**：

```C++
MEMOIZED-LCS-LENGTH-AUX(X, Y, i, j, c, b)
    if c[i, j] > -1
        return c[i, j]
    if i == 0 or j == 0
        c[i, j] = 0
        return c[i, j]
    if x_i == y_j
        b[i, j] = "↖"
        c[i, j] = MEMOIZED-LCS-LENGTH-AUX(X, Y, i - 1, j - 1, c, b) + 1
    else if MEMOIZED-LCS-LENGTH-AUX(X, Y, i - 1, j, c, b) ≥ MEMOIZED-LCS-LENGTH-AUX(X, Y, i, j - 1, c, b)
        b[i, j] = "↑"
        c[i, j] = MEMOIZED-LCS-LENGTH-AUX(X, Y, i - 1, j, c, b)
    else
        b[i, j] = "←"
        c[i, j] = MEMOIZED-LCS-LENGTH-AUX(X, Y, i, j - 1, c, b)
    return c[i, j]

MEMOIZED-LCS-LENGTH(X, Y)
    let b[1 : m, 1 : n] and c[0 : m, 0 : n] be new tables
    for i = 0 to m
        for j = 0 to n
            c[i, j] = -1
    MEMOIZED-LCS-LENGTH-AUX(X, Y, m, n, c, b)
    return c and b
```

### 4.3 最优二叉搜索树

![image-20231225115222104](C:\Users\27476\Desktop\算法教材\图图\image-20231225115222104.png)

给定一个概率集合，我们希望构造一棵搜索代价最小的二叉搜索树

**Step1**：最优二叉搜索树的结构

![image-20231225115346196](C:\Users\27476\Desktop\算法教材\图图\image-20231225115346196.png)

**Step2**：一个递归解

![image-20231225115645242](C:\Users\27476\Desktop\算法教材\图图\image-20231225115645242.png)

![image-20231225115827973](C:\Users\27476\Desktop\算法教材\图图\image-20231225115827973.png)

为了帮助构造最优解，定义$root[i,j]$保存关键字$k_i,\dots,k_{r-1}$的最优二叉树的根节点关键字$k_r$的下表$r$

**Step3**：计算最优二叉搜索树的期望搜索代价

![image-20231225115957016](C:\Users\27476\Desktop\算法教材\图图\image-20231225115957016.png)

![image-20231225120203805](C:\Users\27476\Desktop\算法教材\图图\image-20231225120203805.png)

### 4.4 作业

1. Consider a modification of the rod-cutting problem in which, in addition to a price $p_i $for each rod, each cut incurs a fixed cost of $c$. The revenue associated with a solution is now the sum of the prices of the pieces minus the costs of making the cuts. Give a dynamic-programming algorithm to solve this modified problem.

$$
\begin{aligned}
r_n & =\max \left\{p_1+r_{n-1}-c, p_2+r_{n-2}-c, \cdots, p_{n-1}+r_1-c, p_n\right\} \\
& =\max \left\{p_i+r_{n-i}-c \mid 1 \leq i \leq n, r_0=c\right\}
\end{aligned}
$$

![image-20231225120431998](C:\Users\27476\Desktop\算法教材\图图\image-20231225120431998.png)

2. Give pseudocode(伪代码) to reconstruct an LCS from the completed c table and the original sequences $X=<x_1,x_2,…,x_m>$ and $Y=<y_1,y_2,…,y_n>$ in $O(m+n)$ time, without using the b table.

![image-20231225120605995](C:\Users\27476\Desktop\算法教材\图图\image-20231225120605995.png)

这个函数为$O(m+n)$

3. Determine the cost and structure of an optimal binary search tree for a set of $n=7$ keys with the following probabilities:

![image-20231225120700437](C:\Users\27476\Desktop\算法教材\图图\image-20231225120700437.png)

![image-20231225120817299](C:\Users\27476\Desktop\算法教材\图图\image-20231225120817299.png)

![image-20231225120832237](C:\Users\27476\Desktop\算法教材\图图\image-20231225120832237.png)

## 五. 贪心算法

贪心算法每一步都做出当时看起来是最优的选择，即求局部最优解，希望通过局部最优解推导出全局最优解

### 5.1 活动选择问题（activity-selection problem）

![image-20231225121703007](C:\Users\27476\Desktop\算法教材\图图\image-20231225121703007.png)

**活动选择问题的最优子结构**：

![image-20231225121947045](C:\Users\27476\Desktop\算法教材\图图\image-20231225121947045.png)

**做出贪心选择**：

![image-20231225122052246](C:\Users\27476\Desktop\算法教材\图图\image-20231225122052246.png)

**重要定理**：

考虑任意非空子问题$S_k$，如果$a_m$是$S_k$中结束时间最早的活动，那么$a_m$在$S_k$的某个最大兼容活动子集中

**递归贪心算法**：

![image-20231225122450417](C:\Users\27476\Desktop\算法教材\图图\image-20231225122450417.png)

**迭代贪心算法**：

![image-20231225122622919](C:\Users\27476\Desktop\算法教材\图图\image-20231225122622919.png)

### 5.2 贪心策略基本原理

![image-20231225122952250](C:\Users\27476\Desktop\算法教材\图图\image-20231225122952250.png)

![image-20231225123118444](C:\Users\27476\Desktop\算法教材\图图\image-20231225123118444.png)

![image-20231225123146844](C:\Users\27476\Desktop\算法教材\图图\image-20231225123146844.png)

**贪心VS动态规划**：

![image-20231225123301631](C:\Users\27476\Desktop\算法教材\图图\image-20231225123301631.png)

### 5.3 离线缓存（Offline caching）

![image-20231225123531809](C:\Users\27476\Desktop\算法教材\图图\image-20231225123531809.png)

情况2和情况3称为缓存未命中，情况2称为强制未命中

![image-20231225123702029](C:\Users\27476\Desktop\算法教材\图图\image-20231225123702029.png)

**离线缓存的最优子结构**：

![image-20231225123847529](C:\Users\27476\Desktop\算法教材\图图\image-20231225123847529.png)

**离线缓存的贪心选择性质**：

![image-20231225132144533](C:\Users\27476\Desktop\算法教材\图图\image-20231225132144533.png)

### 5.4 作业

1. Describe an efficient algorithm that, given a set $\{x_1,x_2,…,x_n \}$ of points on the real line, determines the smallest *set* of unit-length closed intervals that contains all of the given points. Argue that your algorithm is correct.

![image-20231225132545892](C:\Users\27476\Desktop\算法教材\图图\image-20231225132545892.png)

2. Real cache managers do not know the future requests, and so they often use the past to decide which block to evict. The least-recently-used, or LRU, strategy evicts the block that, of all blocks currently in the cache, was the least recently requested. Give an example of a request sequence in which the LRU strategy is not optimal, by showing that it induces more cache misses than the furthest-in-future strategy does on the same request sequence

![image-20231225132648569](C:\Users\27476\Desktop\算法教材\图图\image-20231225132648569.png)

## 六. 最小生成树（Minimum Spanning Trees）

![image-20231225212551611](C:\Users\27476\Desktop\算法教材\图图\image-20231225212551611.png)

### 6.1 生成一颗最小生成树

![image-20231225212707280](C:\Users\27476\Desktop\算法教材\图图\image-20231225212707280.png)

**切割**：

![image-20231225212925151](C:\Users\27476\Desktop\算法教材\图图\image-20231225212925151.png)

**重要定理**：

![image-20231225213033734](C:\Users\27476\Desktop\算法教材\图图\image-20231225213033734.png)

### 6.2 Kruskal算法

$A$是一个森林，该森林的顶点为$V$，每次加入到$A$中的安全边永远是权重最小的连接两个不同分量的边

![image-20231225213314966](C:\Users\27476\Desktop\算法教材\图图\image-20231225213314966.png)

### 6.3 Prim算法

$A$是一棵树，每次加入到$A$的安全边永远连接$A$和$V-A$的边中权重最小的边

![image-20231225213516894](C:\Users\27476\Desktop\算法教材\图图\image-20231225213516894.png)

### 6.4 一些概念

* 最小优先队列

![image-20231225213700474](C:\Users\27476\Desktop\算法教材\图图\image-20231225213700474.png)

![image-20231225213732551](C:\Users\27476\Desktop\算法教材\图图\image-20231225213732551.png)

![image-20231225213744150](C:\Users\27476\Desktop\算法教材\图图\image-20231225213744150.png)

### 6.5 作业

1. Give a simple example of a connected graph such that the set of edges $\{(u,v): there\;exists\;a\;cut\;(S,V-S)\;such\;that\;(u,v)\;is\;a\;light\;edge\;crossing\;(S,V-S)\} $does not form a minimum spanning tree

Consider a triangle graph whose 3 edge weights are all equal. Apparently, every edge is a light edge crossing some cut partitioned by 1 vertex and the other 2 vertices. Thus, all light edges form a cycle, but not a minimum spanning tree

2. Give a simple implementation of Prim’s algorithm that runs in $O(V^2)$ time when the graph $G(V,E)$ is represented as an adjacency matrix

![image-20231225214051794](C:\Users\27476\Desktop\算法教材\图图\image-20231225214051794.png)

## 七. 最短路径（Shortest Paths）

![image-20231225214345931](C:\Users\27476\Desktop\算法教材\图图\image-20231225214345931.png)

### 7.1 基本概念

![image-20231225214326212](C:\Users\27476\Desktop\算法教材\图图\image-20231225214326212.png)

**最短路径的最优子结构**：

![image-20231225214503662](C:\Users\27476\Desktop\算法教材\图图\image-20231225214503662.png)

**负权重边**：

![image-20231225214544351](C:\Users\27476\Desktop\算法教材\图图\image-20231225214544351.png)

**环路**：

![image-20231225214640545](C:\Users\27476\Desktop\算法教材\图图\image-20231225214640545.png)

**松弛（relaxation）**：

* $v.d$：从$s$到$v$的最短路径的权重的上界
* $v.\pi$：顶点的前驱

![image-20231225215010573](C:\Users\27476\Desktop\算法教材\图图\image-20231225215010573.png)

![image-20231225215151459](C:\Users\27476\Desktop\算法教材\图图\image-20231225215151459.png)

### 7.2 单源最短路径

**Dijkstra算法**：能够解决有向带权图$G=(V,E)$上的单源最短路径问题，但要求所有边$(u,v)\in E$的权重$w(u,v) \geq0$

![image-20231225215700402](C:\Users\27476\Desktop\算法教材\图图\image-20231225215700402.png)

**时间复杂度**：

![image-20231225215907840](C:\Users\27476\Desktop\算法教材\图图\image-20231225215907840.png)

### 7.3 全源最短路径

![image-20231225220030859](C:\Users\27476\Desktop\算法教材\图图\image-20231225220030859.png)

**Floyd-Warshall算法**：输入图中可以存在权重为负的边，但不能存在权重为负的环路。这个算法是基于可用中间顶点的最大个数进行动态规划

![image-20231225220358747](C:\Users\27476\Desktop\算法教材\图图\image-20231225220358747.png)

![image-20231225220424296](C:\Users\27476\Desktop\算法教材\图图\image-20231225220424296.png)

![image-20231225220612090](C:\Users\27476\Desktop\算法教材\图图\image-20231225220612090.png)

**自底向上计算最短路径权重**：

![image-20231225220708292](C:\Users\27476\Desktop\算法教材\图图\image-20231225220708292.png)

![image-20231225220727267](C:\Users\27476\Desktop\算法教材\图图\image-20231225220727267.png)

**构造一条最短路径**：

![image-20231225220848329](C:\Users\27476\Desktop\算法教材\图图\image-20231225220848329.png)

### 7.4 作业

1. Give a simple example of a directed graph with negative-weight edges for which Dijkstra's algorithm produces an incorrect answer

Consider a graph with a negative-weight cycle reachable from the source. The distance to any vertex reachable from the cycle is -∞, but RELAX algorithm is called only finite times, and hence Dijkstra's algorithm cannot produce a correct answer.

![image-20231225221005755](C:\Users\27476\Desktop\算法教材\图图\image-20231225221005755.png)

2. Show how to use the output of the Floyd-Warshall algorithm to detect the presence of a negative-weight cycle.

If the output of the Floyd-Warshall algorithm has a negative number on the diagonal (the shortest path from a vertex to itself), then there exists a negative-weight cycle.

## 八. NP完全性

### 8.1 一些概念

* P问题：可以在多项式时间内求解的问题
* NP问题：可以在多项式时间内验证的问题（给出一个解，验证这个解是否正确）
* NPC问题：是一个NP问题+所有NP问题都能归约到它
* NP难问题（NP-hard）：所有问题都能归约到它，但是不一定是NP问题
* P问题是NP问题的子集

![image-20231226094324096](C:\Users\27476\Desktop\算法教材\图图\image-20231226094324096.png)

如果有任何一个NPC问题可以在多项式时间内解决，那么所有NP问题都可以在多项式时间内解决

* 决定问题 vs 优化问题（Decision problems vs. optimization problems）

  如果一个决定问题很难，那和它先关联的优化问题也很难

* 规约（Reductions）：

  考虑一个决定问题$A$，我们称$A$的输入为$A$的一个实例（instance）$\alpha$；另一个决定问题$B$可以在多项式时间内解决。现在有一个程序，它可以在**多项式时间**内把$A$的一个实例$\alpha$转换为$B$的一个实例$\beta$，且两个问题输出的**结果相同**

* 现在将多项式时间规约换一种思路使用：

  一个决定问题$A$已经被确定不存在多项式时间算法，且存在一个从$A$到$B$的多项式时间规约，那么对于$B$来说也不存多项式时间算法

  所以要定义NPC问题，就要找到第一个NPC问题

* 问题的抽象表达：

  一个抽象问题$Q$是一个输入集合$I$和一个输出集合$S$上的二元关系。这样可以定义**决定问题**：从输入集合$I$到结果集$\{0,1\}$的映射

* 编码：程序能理解的问题表达形式。

  编码的定义：是一个从抽象实体$S$到二进制串集合的映射$e$，例如

![image-20231226095638407](C:\Users\27476\Desktop\算法教材\图图\image-20231226095638407.png)

​	   一个实例$i$的规模是它对应的字符串$|i|$的长度。

​	   我们将实例集（输入集）是一个二进制串集合的问题称为具体问题（**concrete problem**）

​	   编码可以将抽象问题映射到具体问题

![image-20231226100049068](C:\Users\27476\Desktop\算法教材\图图\image-20231226100049068.png)

![image-20231226100408539](C:\Users\27476\Desktop\算法教材\图图\image-20231226100408539.png)

* P问题的再定义：

![image-20231226100612348](C:\Users\27476\Desktop\算法教材\图图\image-20231226100612348.png)

解决一个问题的复杂度很大程度上取决于它的编码方式：

![image-20231226100512498](C:\Users\27476\Desktop\算法教材\图图\image-20231226100512498.png)

* 两种编码$e_1$和$e_2$**多项式时间相关**：

  存在两个多项式时间计算函数$f_{12}$和$f_{21}$，使得对于任何$i \in I$，满足$f_{12}(e_1(i))=e_2(i)$和$f_{21}(e_2(i))=e_1(i)$

* 关于编码相关的引理：

  令$Q$是一个在实例集$I$上的抽象决定问题，$e_1$和$e_2$是两个$I$上的相关编码，那么$e_1(Q) \in P$当且仅当$e_2(Q) \in P$

* $<G>$表示一个图$G$的编码

* 编码方式的选择和一个抽象问题是否多项式时间可解没有关系

* 语言框架定义：

  一个字母表$\sum$是一个有限的符号集

  在$\sum$上定义的语言$L$是一个字符串集合，其中的字符串由$\sum$上的符号组成

  有空字符串$ε$，空语言$∅$

![image-20231226101545797](C:\Users\27476\Desktop\算法教材\图图\image-20231226101545797.png)

​	   我们可以把问题$Q$看作符号集$\sum=\{0,1\}$上的语言$L$，$L=\{x \in \sum^*:Q(x)=1\}$

* 如果对于一个算法$A$有$A(x)=1$，则称一个算法接受（accept）一个字符串$x \in \{0,1\}^*$

  一个语言$L$被算法$A$接受，等价于$L=\{x \in \{0,1\}^*:A(x)=1\}$

  如果对于一个算法$A$有$A(x)=0$，则称一个算法拒绝（reject）一个字符串$x \in \{0,1\}^*$

  一个语言$L$被一个算法$A$定义，等价于$L$中的每一个二进制串都被A接受，每一个不在$L$中的二进制串都被A拒绝

![image-20231226102336163](C:\Users\27476\Desktop\算法教材\图图\image-20231226102336163.png)

### 8.2 NPC问题

* 确认算法（**Veriﬁcation algorithm**）：

  一个确认算法有两个输入参数，一个是输入串$x$（例如图G的编码），另一个是待验证的解（例如顶点的列表）。算法$A$确认$x$等价于存在$y$使得$A(x,y)=1$

* 语言的规约（**Reducibility**）

  一个语言$L_1$可以在多项式时间内规约到另一个语言$L_2$（$L_1 \leq_P L_2$），等价于存在一个多项式时间计算函数$f:\{0,1\}^* \rightarrow \{0,1\}^*$，使得对于所有的$x \in L_1$当且仅当$x \in L_2$

  ![image-20231226103353030](C:\Users\27476\Desktop\算法教材\图图\image-20231226103353030.png)

* 重要引理：

![image-20231226103446855](C:\Users\27476\Desktop\算法教材\图图\image-20231226103446855.png)

* 如果任何NPC问题都是多项式时间可解的，那么P=NP

  如果任何NP问题都不是多项式时间可解的，那么没有NPC问题是多项式时间可解的

* 电路可满足性问题

![image-20231226103702754](C:\Users\27476\Desktop\算法教材\图图\image-20231226103702754.png)

$\text { CIRCUIT-SAT }=\{\langle C\rangle: C \text { is a satisfiable Boolean combinational circuit }\}$

要证明电路可满足性问题是NPC问题，要分别证明其是NP问题，以及它是NP-hard问题

* NPC问题的证明通式：

![image-20231226104041668](C:\Users\27476\Desktop\算法教材\图图\image-20231226104041668.png)

* $CIRCUIT-SAT \leq_P SAT$

  ![image-20231226104236978](C:\Users\27476\Desktop\算法教材\图图\image-20231226104236978.png)

​		![image-20231226104301712](C:\Users\27476\Desktop\算法教材\图图\image-20231226104301712.png)

* $SAT \leq_P 3-CNF-SAT$（三合取范式）

![image-20231226104426422](C:\Users\27476\Desktop\算法教材\图图\image-20231226104426422.png)

![image-20231226104437347](C:\Users\27476\Desktop\算法教材\图图\image-20231226104437347.png)

![image-20231226104533458](C:\Users\27476\Desktop\算法教材\图图\image-20231226104533458.png)

![image-20231226104454670](C:\Users\27476\Desktop\算法教材\图图\image-20231226104454670.png)

![image-20231226104700933](C:\Users\27476\Desktop\算法教材\图图\image-20231226104700933.png)

* 更多NPC问题

![image-20231226104727847](C:\Users\27476\Desktop\算法教材\图图\image-20231226104727847.png)

### 8.3 作业

1. The subgraph-isomorphism（子图同构） problem takes two undirected graphs $G_1$ and $G_2$, and asks whether $G_1$ is isomorphic to a subgraph of $G_2$. Show that the subgraph-isomorphism problem is NP-complete

(1) Prove SIP ∈ NP.

 Show that a solution to the problem can be verified in polynomial time. Given a injective mapping $f$ from $V_1$ to $V_2$, we can check that for every edge $(u, v)∈E_1$, there is an edge $(f(u), f(v))∈E_2$ in polynomial time $O(|V_1 |^2)$.

(2) Prove $SIP ∈ NPC$ by proving $CLIQUE ≤_P SIP$.

 Show that a known NPC problem, such as the clique problem, can be reduced to SIP. The clique problem takes a graph G and a number k, and asks whether G contains a complete subgraph (a clique) of size k

* **Reduction**: Construct $G_1$ is a complete graph of size k.

Then, $G_2$ contains a clique of size $k$ if and only if $G_1$ is isomorphic to a subgraph of $G_2$. The reduction takes $O(k^2)$ time to construct $G_1$.

2. Given an integer $m×n$ matrix A and an integer m-vector b, the **0-1 integer-programming problem** asks whether there exists an integer n-vector x with elements in the set $\{0,1\}$ such that $Ax≤b$. Prove that 0-1 integer programming is NP-complete. (Hint: Reduce from 3-CNF-SAT.)

(1) Prove 01IP ∈ NP

 Given a solution x, we can verify $Ax≤b$ in $O(mn)$.

(2) Prove $01IP ∈ NPC$ by proving $3-CNF-SAT ≤_P 01IP$.

* **Reduction**:

 To satisfy each clause is true, we can convert it to an inequality. For example,

$x_1∨¬x_2∨¬x_3, x_1+(1-x_2)+(1-x_3)≥1, -x_1+x_2+x_3≤1$

where the final inequality has variables on the left no greater than an integer on the right. If x is not $¬$ operated in the clause, it is converted to $-x$; if $x$ is $¬$ operated, it is converted to $+x$. The integer on the right is the number of $¬$ operations in the clause minus 1.

 Suppose in 3-CNT-SAT the formula $ϕ$ has m clauses and n variables. Now we construct an integer m×n matrix A,
$$
A_{i, j}= \begin{cases}-1,  & \text { if } x_j \text { occurs without }- \text { operation in clause } i \\ 1, & \text { if } x_j \text { occurs with } \neg \text { operation in clause } i \\ 0, & \text { otherwise (if } x_j \text { does not occur in clause } i \text { ) }\end{cases}
$$
Then construct an integer m-vector $b$, $b_i$ is the number of $¬$ operations in clause $i$ minus 1. Thus, m inequalities are combined into a 01IP problem. The 3-CNT-SAT can be satisfied if and only if we can find a vector $x∈\{0, 1\}^n$ such that $Ax≤b$. The reduction takes $O(mn)$ time.

## 九. 分布式算法摘要

### 9.1 分布式计算

* local steps

![image-20231226110329731](C:\Users\27476\Desktop\算法教材\图图\image-20231226110329731.png)

* Step of a process and layering

![image-20231226110514934](C:\Users\27476\Desktop\算法教材\图图\image-20231226110514934.png)

* JobHandler specification

```
Implements: JobHandler, instance jh.
Get familiar with the event-driven style

upon event < jh, Submit | job > do
	process(job);
	trigger < jh, Confirm | job >;
	
upon event < jh, Init > do
	buffer := ∅;

upon event < jh, Submit | job > do
	buffer := buffer ∪ {job};
	trigger < jh, Confirm | job >;

upon buffer ≠ ∅ do
	job := selectjob(buffer);
	process(job);
	buffer := buffer \ {job};
```

### 9.2 抽象错误（Abstracting Failures）

当一个进程没有按照算法规定来执行，就称发生了一个错误

Faulty processes:

* Crash（crash-stop）
  * Process stops execution of the algorithm: crashes
  * Process may crash in the middle of a step
* Crash-recovery
  * Process might temporarily crash, but then recover its state and proceed taking steps
  * Process may crash and recover for an infinite number of times
* Omission
  * The process omits to send/receive messages it is supposed to send/receive
  * Due to, e.g., buffer overflows or network congestion
* Byzantine
  * Unrestricted, arbitrary
  * Malicious behavior allowed, models intrusions, bugs, etc
  * Special case: Authenticated Byzantine fault

### 9.3 抽象通信（Abstracting Communication）

传输中的消息可能会丢失，因此需要一些处理

* **Fair-loss links**

![image-20231226111339684](C:\Users\27476\Desktop\算法教材\图图\image-20231226111339684.png)

* **Stubborn links**

![image-20231226111405150](C:\Users\27476\Desktop\算法教材\图图\image-20231226111405150.png)

实现：

```python
Implements: StubbornLink (sl).
Uses: FairLossLink (fll).

upon event < sl, Init > do
	sent := ∅;
	starttimer(Δ);

upon event < Timeout > do
	forall (q, m) ∈ sent do
		trigger < fll, Send | q, m >;
	starttimer(Δ);

upon event < sl, Send | q, m > do
	trigger < fll, Send | q, m >;
	sent := sent ∪ {(q, m)};

upon event < fll, Deliver | p, m > do
	trigger < sl, Deliver | p, m >;
```

* Perfect（Reliable）links

![image-20231226111529344](C:\Users\27476\Desktop\算法教材\图图\image-20231226111529344.png)

实现：

```python
Implements: PerfectPointToPointLinks, instance pl.
Uses: StubbornPointToPointLinks, instance sl.

upon event < pl, Init > do
	delivered := ∅;

upon event < pl, Send | q, m > do
	trigger < sl, Send | q, m >;

upon event < sl, Deliver | p, m > do
	if m ∉ delivered then
		delivered := delivered ∪ {m};
		trigger < pl, Deliver | p, m >;

```

### 9.4 时间评估（Timing Assumptions）

![image-20231226111756935](C:\Users\27476\Desktop\算法教材\图图\image-20231226111756935.png)

### 9.5 抽象时间（Abstracting time）

根据时间评估来检测进程错误是不可靠的，定义错误检测器（Failure detectors）

错误检测器的两大性质：Completeness、Accuracy

![image-20231226112055758](C:\Users\27476\Desktop\算法教材\图图\image-20231226112055758.png)

![image-20231226112126620](C:\Users\27476\Desktop\算法教材\图图\image-20231226112126620.png)

**实现**：

```Python
Implements: PerfectFailureDetector, instance P.
Uses: PerfectPointToPointLinks, instance pl.

upon event < P, Init > do
	alive := Π;
	detected := ∅;
	starttimer(2∆);

upon event < Timeout > do
	forall p ∈ Π do
		if (p ∉ alive) ∧ (p ∉ detected) then
			detected := detected ∪ {p};
			trigger < P, Crash | p >;
		trigger < pl, Send | p, [HEARTBEAT_REQUEST] >;
	alive := ∅;
	starttimer(2∆);

upon event < pl, Deliver | q, [HEARTBEAT_REQUEST] > do
	trigger < pl, Send | q, [HEARTBEAT_REPLY] >;

upon event < pl, Deliver | p, [HEARTBEAT_REPLY] > do
	alive := alive ∪ {p};
```

**实例**：

![image-20231226112211593](C:\Users\27476\Desktop\算法教材\图图\image-20231226112211593.png)

![image-20231226112234058](C:\Users\27476\Desktop\算法教材\图图\image-20231226112234058.png)

**实现**：

```python
upon event < ◇P, Init > do
	alive := Π;
	suspected := ∅;
	delay := 2∆’;
	starttimer(delay);

upon event < Timeout > do
	if alive ∩ suspected ≠ ∅ then
		delay := delay + 2∆’;
	forall p ∈ Π do
		if (p ∉ alive) ∧ (p ∉ suspected) then
			suspected := suspected ∪ {p};
			trigger < ◇P, Suspect | p >;
		else if (p ∈ alive) ∧ (p ∈ suspected) then
			suspected := suspected \ {p};
			trigger < ◇P, Restore | p >;
		trigger < pl, Send | p, [HEARTBEAT_REQUEST] >;
	alive := ∅;
	starttimer(delay);
    
upon event < pl, Deliver | q, [HEARTBEAT_REQUEST] > do
	trigger < pl, Send | q, [HEARTBEAT_REPLY] >;

upon event < pl, Deliver | p, [HEARTBEAT_REPLY] > do
	alive := alive ∪ {p};
```

需要注意的是$\Delta$事先是不知道的

**实例**：

![image-20231226112342759](C:\Users\27476\Desktop\算法教材\图图\image-20231226112342759.png)

**Leader Election**：

![image-20231226112522174](C:\Users\27476\Desktop\算法教材\图图\image-20231226112522174.png)

**实现**：

```python
Implements: LeaderElection, instance le.
Uses: PerfectFailureDetector, instance P.

upon event < le, Init > do
	suspected := ∅;
	leader := ⊥;

upon event < P , Crash | p > do
	suspected := suspected ∪ {p};

upon leader ≠ maxrank(Π \ suspected) do
	leader := maxrank(Π \ suspected);
	trigger <le, Leader | leader >;
```

**实例**：

![image-20231226112553733](C:\Users\27476\Desktop\算法教材\图图\image-20231226112553733.png)

![image-20231226112623055](C:\Users\27476\Desktop\算法教材\图图\image-20231226112623055.png)

**实现**：

```python
Implements: EventualLeaderDetector, instance Ω.
Uses: EventuallyPerfectFailureDetector, instance ◇P.

upon event < Ω, Init > do
	suspected := ∅;
	leader := ⊥;

upon event < ◇P, Suspect | p > do
	suspected := suspected ∪ {p};

upon event < ◇P, Restore | p > do
	suspected := suspected \ {p};

upon leader ≠ maxrank(Π \ suspected) do
	leader := maxrank(Π \ suspected);
	trigger < Ω, Trust | leader >;
```

**实例**：

![image-20231226112657834](C:\Users\27476\Desktop\算法教材\图图\image-20231226112657834.png)

### 9.6 作业

1. What happens if the assumption for Δ does not hold? Which property is violated? Give an example

![image-20231226112745370](C:\Users\27476\Desktop\算法教材\图图\image-20231226112745370.png)

![image-20231226112757440](C:\Users\27476\Desktop\算法教材\图图\image-20231226112757440.png)

2. If we would prefer p2 to be the leader (though it may crash), give an eventual leader detection algorithm that additionally ensures。If p2 does not crash, then eventually p2 is elected as the leader by every correct process

**法一**：

```python
upon event < Ω, Init > do
	suspected := ∅;
	leader := ⊥;

upon event < ◇P, Suspect | p > do
	suspected := suspected ∪ {p};

upon event < ◇P, Restore | p > do
	suspected := suspected \ {p};

upon (p2 ∈ Π \ suspected and leader ≠ p2) or (p2 ∈ suspected and leader ≠  maxrank(Π \ suspected)) do
	if p2 ∈ Π \ suspected then
		leader := p2;
	else
		leader := maxrank(Π \ suspected);
	trigger < Ω, Trust | leader >;

```

**法二**：

![image-20231226113003578](C:\Users\27476\Desktop\算法教材\图图\image-20231226113003578.png)

## 十. 广播（broadcast）

### 10.1 Reliable broadcast primitives

* **Best-effort broadcast**

![image-20231226145204552](C:\Users\27476\Desktop\算法教材\图图\image-20231226145204552.png)

**实现**：

![image-20231226145747620](C:\Users\27476\Desktop\算法教材\图图\image-20231226145747620.png)

评：no creation和no duplication都是直接依赖于perfect links实现的；一次通信会产生$O(N)$条信息

* **(Regular) Reliable Broadcast**

![image-20231226145526172](C:\Users\27476\Desktop\算法教材\图图\image-20231226145526172.png)

**实现（Lazy）**：

![image-20231226145812548](C:\Users\27476\Desktop\算法教材\图图\image-20231226145812548.png)

评：最好情况下是一次通信和产生$O(N)$条消息；最坏情况下是$O(N)$次通信和$O(N^2)$条消息

**实现（Eager）：**

![image-20231226150152721](C:\Users\27476\Desktop\算法教材\图图\image-20231226150152721.png)

评：最好情况下是一次通信和产生$O(N^2)$条消息；最坏情况下是$O(N)$次通信和$O(N^2)$条消息

* **Uniform reliable broadcast**

![image-20231226150300012](C:\Users\27476\Desktop\算法教材\图图\image-20231226150300012.png)

**实现（All-Ack Uniform Reliable Broadcast）**：

![image-20231226150414557](C:\Users\27476\Desktop\算法教材\图图\image-20231226150414557.png)

![image-20231226150424085](C:\Users\27476\Desktop\算法教材\图图\image-20231226150424085.png)

![image-20231226150510111](C:\Users\27476\Desktop\算法教材\图图\image-20231226150510111.png)

评：最好情况下是两次通信和产生$O(N^2)$条消息；最坏情况下是$O(N)$次通信和$O(N^2)$条消息

### 10.2 Quorum

![image-20231226150703995](C:\Users\27476\Desktop\算法教材\图图\image-20231226150703995.png)

不同的子集之间必须相交非空！！！

假设现在有$f$个crash，还存活着$N-f$个进程可以工作，那么必须满足$2(N-f)>N$，即$N>2f$

### 10.3 Majority-Ack Uniform Reliable Broadcast

不使用PerfectFaliureDetector来实现Uniform reliable broadcast：

![image-20231226151153186](C:\Users\27476\Desktop\算法教材\图图\image-20231226151153186.png)

![image-20231226151208248](C:\Users\27476\Desktop\算法教材\图图\image-20231226151208248.png)

正确性解释：

![image-20231226151320850](C:\Users\27476\Desktop\算法教材\图图\image-20231226151320850.png)

![image-20231226151332261](C:\Users\27476\Desktop\算法教材\图图\image-20231226151332261.png)

评：最好情况下是两次通信和产生$O(N^2)$条消息；最坏情况下是$O(N)$次通信和$O(N^2)$条消息

### 10.4 Causal-order broadcast primitives

保证了收到的消息在逻辑上的前后一致，每个进程要维护自己的计数器，每次发送消息时要把自己的计数器信息一同发送

![image-20231226151619545](C:\Users\27476\Desktop\算法教材\图图\image-20231226151619545.png)

但logic clocks仍然存在问题：Logical clocks cannot convey causal relation

![image-20231226151800039](C:\Users\27476\Desktop\算法教材\图图\image-20231226151800039.png)

于是使用Vector clocks

![image-20231226151845430](C:\Users\27476\Desktop\算法教材\图图\image-20231226151845430.png)

![image-20231226152022030](C:\Users\27476\Desktop\算法教材\图图\image-20231226152022030.png)

![image-20231226152152906](C:\Users\27476\Desktop\算法教材\图图\image-20231226152152906.png)

![image-20231226152227482](C:\Users\27476\Desktop\算法教材\图图\image-20231226152227482.png)

**实现（No-Waiting Causal-Order Broadcast）：**

![image-20231226152307240](C:\Users\27476\Desktop\算法教材\图图\image-20231226152307240.png)

为了解决pass[]规模过大占用空间的问题，要采取截断的方法

![image-20231226152543009](C:\Users\27476\Desktop\算法教材\图图\image-20231226152543009.png)

也可以完全去掉pass[]，即实现**Waiting Causal Broadcast**

![image-20231226152635524](C:\Users\27476\Desktop\算法教材\图图\image-20231226152635524.png)

要实现**Uniform Reliable Causal Order Broadcast**的话，直接将rbBroadcast换成urbBroadcast

### 10.5 作业

1. Can we devise an uniform reliable broadcast algorithm using eventually perfect failure detector?

![image-20231226152820927](C:\Users\27476\Desktop\算法教材\图图\image-20231226152820927.png)

2. Can we devise a broadcast algorithm that does not ensure the causal delivery property but only its non-uniform variant：no **correct** process p delivers a message m2 unless p has already delivered every message m1 such that m1 → m2?

![image-20231226152941675](C:\Users\27476\Desktop\算法教材\图图\image-20231226152941675.png)

## 十一. Consensus

一组进程中的一部分crash掉了，要解决的问题是使剩余的正常进程对后续的工作达成共识

### 11.1 最基本的consensus

![image-20231226153219508](C:\Users\27476\Desktop\算法教材\图图\image-20231226153219508.png)

### 11.2 Uniform consensus

![image-20231226153500391](C:\Users\27476\Desktop\算法教材\图图\image-20231226153500391.png)

### 11.3 Consensus算法1

![image-20231226153647343](C:\Users\27476\Desktop\算法教材\图图\image-20231226153647343.png)

![image-20231226153714494](C:\Users\27476\Desktop\算法教材\图图\image-20231226153714494.png)

![image-20231226153731636](C:\Users\27476\Desktop\算法教材\图图\image-20231226153731636.png)

### 11.4 Consensus算法2

![image-20231226153907877](C:\Users\27476\Desktop\算法教材\图图\image-20231226153907877.png)

![image-20231226153926125](C:\Users\27476\Desktop\算法教材\图图\image-20231226153926125.png)

![image-20231226153936381](C:\Users\27476\Desktop\算法教材\图图\image-20231226153936381.png)

### 11.5 Total Order Broadcast

![image-20231226154135547](C:\Users\27476\Desktop\算法教材\图图\image-20231226154135547.png)

而Total Order要求所有进程发送信息的顺序是一致的，但不要求因果性

![image-20231226154242765](C:\Users\27476\Desktop\算法教材\图图\image-20231226154242765.png)

![image-20231226154258075](C:\Users\27476\Desktop\算法教材\图图\image-20231226154258075.png)

![image-20231226154309282](C:\Users\27476\Desktop\算法教材\图图\image-20231226154309282.png)

### 11.6 Consensus算法3

![image-20231226154406438](C:\Users\27476\Desktop\算法教材\图图\image-20231226154406438.png)

![image-20231226154611078](C:\Users\27476\Desktop\算法教材\图图\image-20231226154611078.png)

![image-20231226154820471](C:\Users\27476\Desktop\算法教材\图图\image-20231226154820471.png)

![image-20231226154832137](C:\Users\27476\Desktop\算法教材\图图\image-20231226154832137.png)

![image-20231226154846230](C:\Users\27476\Desktop\算法教材\图图\image-20231226154846230.png)

![image-20231226154857349](C:\Users\27476\Desktop\算法教材\图图\image-20231226154857349.png)

正确性说明：

![image-20231226155002255](C:\Users\27476\Desktop\算法教材\图图\image-20231226155002255.png)

**Correctness argument: Termination**：

![image-20231226155011702](C:\Users\27476\Desktop\算法教材\图图\image-20231226155011702.png)

**Correctness argument: Agreement**：

![image-20231226155042715](C:\Users\27476\Desktop\算法教材\图图\image-20231226155042715.png)

### 11.7 作业

1. Implement Consensus using total-order broadcast

![image-20231226155138894](C:\Users\27476\Desktop\算法教材\图图\image-20231226155138894.png)

2. Explain why any consensus algorithm that uses Eventually Perfect Faliure Detector actually solves uniform consensus

![image-20231226155226115](C:\Users\27476\Desktop\算法教材\图图\image-20231226155226115.png)

## 十二. 共识的应用

### 12.1 **Terminating reliable broadcast**

对于通常的Uniform reliable broadcast，如果发送消息的进程在发送前就crash了，那其他的进程就会无限等待消息，这显然不是我们想要的

![image-20231229161056508](C:\Users\27476\Desktop\算法教材\图图\image-20231229161056508.png)

Terminating reliable broadcast中的正常进程会在收不到消息时模拟收到了一个默认值

![image-20231229161207854](C:\Users\27476\Desktop\算法教材\图图\image-20231229161207854.png)

![image-20231229161324559](C:\Users\27476\Desktop\算法教材\图图\image-20231229161324559.png)

![image-20231229161415785](C:\Users\27476\Desktop\算法教材\图图\image-20231229161415785.png)

![image-20231229161443586](C:\Users\27476\Desktop\算法教材\图图\image-20231229161443586.png)

**实现**：

![image-20231229161515611](C:\Users\27476\Desktop\算法教材\图图\image-20231229161515611.png)

![image-20231229161555379](C:\Users\27476\Desktop\算法教材\图图\image-20231229161555379.png)

![image-20231229161609260](C:\Users\27476\Desktop\算法教材\图图\image-20231229161609260.png)

**正确性**：

* Integrity：No other value is proposed to consensus, the property follows by consensus Validity

* Validity：

![image-20231229161731518](C:\Users\27476\Desktop\算法教材\图图\image-20231229161731518.png)

* Uniform Agreement：By Consensus Uniform Agreement
* Termination：

![image-20231229161816744](C:\Users\27476\Desktop\算法教材\图图\image-20231229161816744.png)

### 12.2 Group membership

用来提供关于当前那些进程正处于工作状态的信息，与错误检测器是有区别的，错误检测器可能会导致各个进程收到的信息不一致

![image-20231229162106116](C:\Users\27476\Desktop\算法教材\图图\image-20231229162106116.png)

![image-20231229162134652](C:\Users\27476\Desktop\算法教材\图图\image-20231229162134652.png)

![image-20231229162148254](C:\Users\27476\Desktop\算法教材\图图\image-20231229162148254.png)

**实现**：

![image-20231229162212075](C:\Users\27476\Desktop\算法教材\图图\image-20231229162212075.png)

**正确性**：

![image-20231229162316880](C:\Users\27476\Desktop\算法教材\图图\image-20231229162316880.png)

![image-20231229162330780](C:\Users\27476\Desktop\算法教材\图图\image-20231229162330780.png)

### 12.3 Non-blocking Atomic Commit(NBAC)

用于数据库交互通信（Used in database transactions）

一次交互通信（transaction）可以是committing，也可以是aborting。一次transaction中的操作要么全做，要么全不做

**ACID性质**：

* Atomicity：a transaction either performs entirely or none at all
* Consistency：a transaction transforms a consistent state into another consistent state
* Isolation：a transaction appears to be executed in isolation
* Durability：the effects of a transaction that commits are permanent（永久的）

![image-20231229162856925](C:\Users\27476\Desktop\算法教材\图图\image-20231229162856925.png)

![image-20231229162908929](C:\Users\27476\Desktop\算法教材\图图\image-20231229162908929.png)

![image-20231229163001297](C:\Users\27476\Desktop\算法教材\图图\image-20231229163001297.png)

![image-20231229163033555](C:\Users\27476\Desktop\算法教材\图图\image-20231229163033555.png)

![image-20231229163044419](C:\Users\27476\Desktop\算法教材\图图\image-20231229163044419.png)

**实现**：

![image-20231229163100908](C:\Users\27476\Desktop\算法教材\图图\image-20231229163100908.png)

**正确性**：

![image-20231229163156707](C:\Users\27476\Desktop\算法教材\图图\image-20231229163156707.png)

![image-20231229163205517](C:\Users\27476\Desktop\算法教材\图图\image-20231229163205517.png)

### 12.4 作业

1. Try to implement P assuming utrb (and perfect links）

![image-20231229163252330](C:\Users\27476\Desktop\算法教材\图图\image-20231229163252330.png)

2. Can you implement P using gm

![image-20231229163314275](C:\Users\27476\Desktop\算法教材\图图\image-20231229163314275.png)

## 十三. Miscellaneous（杂项）

![image-20231229163503525](C:\Users\27476\Desktop\算法教材\图图\image-20231229163503525.png)

![image-20231229163518842](C:\Users\27476\Desktop\算法教材\图图\image-20231229163518842.png)

![image-20231229163534132](C:\Users\27476\Desktop\算法教材\图图\image-20231229163534132.png)

![image-20231229163548707](C:\Users\27476\Desktop\算法教材\图图\image-20231229163548707.png)

![image-20231229163605805](C:\Users\27476\Desktop\算法教材\图图\image-20231229163605805.png)

![image-20231229163618043](C:\Users\27476\Desktop\算法教材\图图\image-20231229163618043.png)

![image-20231229163637323](C:\Users\27476\Desktop\算法教材\图图\image-20231229163637323.png)

![image-20231229163650195](C:\Users\27476\Desktop\算法教材\图图\image-20231229163650195.png)

![image-20231229163701107](C:\Users\27476\Desktop\算法教材\图图\image-20231229163701107.png)

![image-20231229163716084](C:\Users\27476\Desktop\算法教材\图图\image-20231229163716084.png)
